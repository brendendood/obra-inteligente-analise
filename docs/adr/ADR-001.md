# ADR-001: Padrão de Módulos e Boundaries

**Status**: Aceito  
**Data**: 2025-08-25  
**Decisores**: MadenAI Architecture Team

## 📋 Contexto

O projeto MadenAI cresceu organicamente e desenvolveu inconsistências na organização de código:

- **Dependências circulares** entre components, hooks e integrations
- **Acoplamento forte** entre camadas de UI e dados
- **Dificuldade de testes** devido a dependências complexas
- **Inconsistência** na forma como diferentes módulos acessam funcionalidades
- **Manutenibilidade comprometida** por violações arquiteturais

### Problemas Identificados

1. Components acessando diretamente integrações (Supabase)
2. Hooks importando components (dependência circular)
3. Utils com dependências internas desnecessárias
4. Integrations conhecendo detalhes de UI
5. Ausência de camada de abstração para APIs externas

## ⚖️ Decisão

Estabelecemos **hierarquia rígida de dependências** com boundaries claros:

### 🎯 Hierarquia Definida
```
Pages → Components → Hooks → Facades → Integrations
  ↓         ↓         ↓        ↓
Utils ← Utils ← Utils ← Utils
```

### 📐 Regras de Dependência

1. **Components**:
   - ✅ Podem usar: Hooks, Utils, Facades
   - ❌ Não podem usar: Integrations diretas, Contexts via import

2. **Hooks**:
   - ✅ Podem usar: Utils, Integrations, Facades
   - ❌ Não podem usar: Components, Contexts via import

3. **Facades**:
   - ✅ Podem usar: Integrations, Utils
   - ❌ Não podem usar: Components, Hooks, React

4. **Integrations**:
   - ✅ Podem usar: Utils apenas
   - ❌ Não podem usar: Qualquer módulo interno

5. **Utils**:
   - ✅ Podem usar: Bibliotecas externas apenas
   - ❌ Não podem usar: Qualquer módulo interno

### 🎭 Introdução de Facades

- **AuthFacade**: Abstrai operações de autenticação
- **ProjectFacade**: Abstrai operações de projeto
- **AIFacade**: Abstrai interações com IA/N8N
- **StorageFacade**: Abstrai operações de arquivo

## ✅ Consequências

### Positivas

1. **Testabilidade**: Cada módulo pode ser testado isoladamente
2. **Manutenibilidade**: Mudanças em uma camada não afetam outras
3. **Clareza**: Responsabilidades bem definidas
4. **Reutilização**: Components independentes de contexto
5. **Substituibilidade**: Integrações podem ser trocadas via facades

### Negativas

1. **Complexidade inicial**: Mais arquivos e abstrações
2. **Curva de aprendizado**: Desenvolvedores precisam entender boundaries
3. **Refactoring extenso**: Código existente precisa ser reorganizado
4. **Overhead**: Camadas adicionais podem adicionar complexidade

### Mitigações

- **Documentação clara** de boundaries em `/docs/architecture/BOUNDARIES.md`
- **ESLint rules** para enforçar boundaries automaticamente
- **Refactoring gradual** com facades como ponte
- **Exemplos práticos** e templates para novos módulos

## 🔧 Implementação

1. **Fase 1**: Criar facades para integrações existentes
2. **Fase 2**: Migrar hooks para usar facades
3. **Fase 3**: Atualizar components para usar apenas hooks
4. **Fase 4**: Isolar integrations e utils
5. **Fase 5**: Configurar ESLint para enforçar boundaries

## 📊 Métricas de Sucesso

- Zero dependências circulares (analisadas via tooling)
- 100% de coverage em testes unitários para facades
- Tempo de build reduzido em 30%
- Componentes reutilizáveis aumentados em 50%

---

**Revisão**: Anual ou quando problemas significativos surgirem  
**Responsável**: Architecture Team